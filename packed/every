#!/usr/bin/env perl
use strict;
use warnings;

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Every.pm"} = <<'APP_EVERY';
  # ABSTRACT: stuff things in cron
  package App::Every;
  {
    $App::Every::VERSION = '0.1.0';
  }
  use strict;
  use warnings;
  use feature qw( switch say );
  use Cwd;
  use Digest::MD5 qw( md5_hex );
  
  sub help {
      warn "Form: $0 [-l] ([num] unit)... program\n";
      warn "-l   - Add locking so that more then one copy can't run at once.\n";
      warn "--dry-run\n";
      warn "-n   - Don't actually install the crontab\n";
      warn "num  - Number of the unit, defaults to 1\n";
      warn "unit - min(ute)(s), hour(s), day(s), week(s), month(s)\n";
      warn "       or the name of a day of week, eg tue(sday)\n";
      exit(1);
  }
  
  =for future todo
  
  Update grammar to replace optional '--' with required 'do' to separate the
  program.  
  
  Later: Without 'do', behave like 'at' and read an ad-hoc script from stdin.
  Also: Small wrapper for 'at' that adds support for a 'do' argument, with a
  set of rc files to alias at with its replacement.  Since 'do' would be invalid
  in an at timespec, it won't interfere with traditional use.
  
  This would ultimately allow for a much more sophisticated grammar
  (eg, Marpa).
  
  If running as root, default to installing in, in order of preference:
      /etc/cron.<period> if available and appropriate
      /etc/cron.d if available
      /etc/crontab
  With --crontab option to install via the crontab command instead.
  Likewise, --system option to try to install in the system crontab even if
  we're not root.
  
      every day at 3pm program...
  
      every minute on Feb 03 at 3pm program...
      
      every day in march program...
  
      at <time>
  
  Where time is HH(:MM)? (24hour time) HH(:MM(am|pm))? (12hour time)
  Or noon or midnight.  Perhaps later, sunrise and sunset.
  
      on <month> <day>
  
  Where month is a full month name or an unambiguous abbreviation and day is
  a number optionally followed by a noise suffix (eg th, nd, etc)
  
      in <month>
  
  Where month is a month as in on.
  
  =cut
  
  
  
  my %monmap = (
      mon   =>1, tue    =>2, wed      =>3, thu     =>4, fri   =>5, sat     =>6, sun   =>7,
      monday=>1, tuesday=>2, wednesday=>3, thursday=>4, friday=>5, saturday=>6, sunday=>7
      );
  my %schedule = (
     minute => "*",
     hour   => "*",
     day    => "*",
     month  => "*",
     dow    => "*" );
  
  sub main {
      my $class = shift;
      my $cwd = getcwd();
      my ($min,$hour,$day,$mon,$year,$dow) = (localtime())[1..6];
      my $lock    = 0;
      my $dry_run = 0;
      my @program;
      while (@_) {
          my $amount = 1;
          given (shift) {
              when ('--') {
                  @program = @_;
                  last;
              }
              when ('-l') {
                  $lock = 1;
              }
              when ([qw( -n --dry-run )]) {
                  $dry_run = 1;
              }
              when (/^-/) {
                  help();
              }
              when (/^\d+$/) {
                  ($amount,$_) = ($_,shift);
                  continue;
              }
              when ([qw( min mins minute minutes )]) {
                  @schedule{qw( minute )}          = ("*/$amount");
              }
              when ([qw( hour hours              )]) {
                  @schedule{qw( minute hour)}      = ($min, "*/$amount");
              }
              when (/^[@]hour(ly)?$/) {
                  @schedule{qw( minute hour day month dow )} = (q{@hourly}, q{}, q{}, q{}, q{});
              }
              when ([qw( midnight )]) {
                  @schedule{qw( minute hour day)}  = ("0", "0", "*/$amount");
              }
              when ([qw( day days                )]) {
                  @schedule{qw( minute hour day )} = ($min,$hour,"*/$amount");
              }
              when (/^( [@]day | [@]daily | [@]midnight )$/x) {
                  @schedule{qw( minute hour day month dow )} = (q{@daily}, q{}, q{}, q{}, q{});
              }
              when ([qw( week weeks )]) {
                  die "Don't know how to iterate less then once a week but more then once a month.\n" if $amount > 1;
                  @schedule{qw( minute hour dow )} = ($min,$hour,$dow);
              }
              when (/^[@]week(ly)?$/) {
                  @schedule{qw( minute hour day month dow )} = (q{@weekly}, q{}, q{}, q{}, q{});
              }
              when (\%monmap) {
                  @schedule{qw( minute hour dow )} = ($min,$hour,$monmap{$_});
              }
              when ([qw( month months )]) {
                  @schedule{qw( minute hour day month )} = ($min,$hour,$day,"*/$amount");
              }
              when ([qw( year )]) {
                  @schedule{qw( minte hour day month )} = ($min,$hour,$day,$mon);
              }
              when (/^[@]year(ly)?$/) {
                  @schedule{qw( minute hour day month dow )} = (q{@yearly}, q{}, q{}, q{}, q{});
              }
              when (/^[@]?reboot$/) {
                  @schedule{qw( minute hour day month dow )} = (q{@reboot}, q{}, q{}, q{}, q{});
              }
              default {
                  @program = ($_,@_);
                  last;
              }
          }
      }
      unless (@program) {
          help();
      }
      unshift @program, qq[cd "$cwd"; ];
  
      if ($lock) {
          my $lockfile = "/tmp/every_lock_" .
             join '_',@schedule{qw( minute hour day month dow )}, @program;
          @program = ("[ ! -f $lockfile -o ! -d /proc/\$(cat $lockfile 2>/dev/null) ] && ( echo \$\$ > $lockfile ;", @program, " ; rm $lockfile )");
      }
  
      my $crontab = join ' ',  @schedule{qw( minute hour day month dow )}, @program;
      say $crontab;
  
      unless ($dry_run) {
          open my $cron, "|-", "crontab";
          print $cron qx{crontab -l 2> /dev/null};
          say $cron $crontab;
          close $cron;
      }
  }
  1;
APP_EVERY

$fatpacked{"i686-linux/Digest/MD5.pm"} = <<'I686-LINUX_DIGEST_MD5';
  package Digest::MD5;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT_OK);
  
  $VERSION = '2.52';
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT_OK = qw(md5 md5_hex md5_base64);
  
  eval {
      require Digest::base;
      push(@ISA, 'Digest::base');
  };
  if ($@) {
      my $err = $@;
      *add_bits = sub { die $err };
  }
  
  
  eval {
      require XSLoader;
      XSLoader::load('Digest::MD5', $VERSION);
  };
  if ($@) {
      my $olderr = $@;
      eval {
  	# Try to load the pure perl version
  	require Digest::Perl::MD5;
  
  	Digest::Perl::MD5->import(qw(md5 md5_hex md5_base64));
  	unshift(@ISA, "Digest::Perl::MD5");  # make OO interface work
      };
      if ($@) {
  	# restore the original error
  	die $olderr;
      }
  }
  else {
      *reset = \&new;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Digest::MD5 - Perl interface to the MD5 Algorithm
  
  =head1 SYNOPSIS
  
   # Functional style
   use Digest::MD5 qw(md5 md5_hex md5_base64);
  
   $digest = md5($data);
   $digest = md5_hex($data);
   $digest = md5_base64($data);
  
   # OO style
   use Digest::MD5;
  
   $ctx = Digest::MD5->new;
  
   $ctx->add($data);
   $ctx->addfile($file_handle);
  
   $digest = $ctx->digest;
   $digest = $ctx->hexdigest;
   $digest = $ctx->b64digest;
  
  =head1 DESCRIPTION
  
  The C<Digest::MD5> module allows you to use the RSA Data Security
  Inc. MD5 Message Digest algorithm from within Perl programs.  The
  algorithm takes as input a message of arbitrary length and produces as
  output a 128-bit "fingerprint" or "message digest" of the input.
  
  Note that the MD5 algorithm is not as strong as it used to be.  It has
  since 2005 been easy to generate different messages that produce the
  same MD5 digest.  It still seems hard to generate messages that
  produce a given digest, but it is probably wise to move to stronger
  algorithms for applications that depend on the digest to uniquely identify
  a message.
  
  The C<Digest::MD5> module provide a procedural interface for simple
  use, as well as an object oriented interface that can handle messages
  of arbitrary length and which can read files directly.
  
  =head1 FUNCTIONS
  
  The following functions are provided by the C<Digest::MD5> module.
  None of these functions are exported by default.
  
  =over 4
  
  =item md5($data,...)
  
  This function will concatenate all arguments, calculate the MD5 digest
  of this "message", and return it in binary form.  The returned string
  will be 16 bytes long.
  
  The result of md5("a", "b", "c") will be exactly the same as the
  result of md5("abc").
  
  =item md5_hex($data,...)
  
  Same as md5(), but will return the digest in hexadecimal form. The
  length of the returned string will be 32 and it will only contain
  characters from this set: '0'..'9' and 'a'..'f'.
  
  =item md5_base64($data,...)
  
  Same as md5(), but will return the digest as a base64 encoded string.
  The length of the returned string will be 22 and it will only contain
  characters from this set: 'A'..'Z', 'a'..'z', '0'..'9', '+' and
  '/'.
  
  Note that the base64 encoded string returned is not padded to be a
  multiple of 4 bytes long.  If you want interoperability with other
  base64 encoded md5 digests you might want to append the redundant
  string "==" to the result.
  
  =back
  
  =head1 METHODS
  
  The object oriented interface to C<Digest::MD5> is described in this
  section.  After a C<Digest::MD5> object has been created, you will add
  data to it and finally ask for the digest in a suitable format.  A
  single object can be used to calculate multiple digests.
  
  The following methods are provided:
  
  =over 4
  
  =item $md5 = Digest::MD5->new
  
  The constructor returns a new C<Digest::MD5> object which encapsulate
  the state of the MD5 message-digest algorithm.
  
  If called as an instance method (i.e. $md5->new) it will just reset the
  state the object to the state of a newly created object.  No new
  object is created in this case.
  
  =item $md5->reset
  
  This is just an alias for $md5->new.
  
  =item $md5->clone
  
  This a copy of the $md5 object. It is useful when you do not want to
  destroy the digests state, but need an intermediate value of the
  digest, e.g. when calculating digests iteratively on a continuous data
  stream.  Example:
  
      my $md5 = Digest::MD5->new;
      while (<>) {
  	$md5->add($_);
  	print "Line $.: ", $md5->clone->hexdigest, "\n";
      }
  
  =item $md5->add($data,...)
  
  The $data provided as argument are appended to the message we
  calculate the digest for.  The return value is the $md5 object itself.
  
  All these lines will have the same effect on the state of the $md5
  object:
  
      $md5->add("a"); $md5->add("b"); $md5->add("c");
      $md5->add("a")->add("b")->add("c");
      $md5->add("a", "b", "c");
      $md5->add("abc");
  
  =item $md5->addfile($io_handle)
  
  The $io_handle will be read until EOF and its content appended to the
  message we calculate the digest for.  The return value is the $md5
  object itself.
  
  The addfile() method will croak() if it fails reading data for some
  reason.  If it croaks it is unpredictable what the state of the $md5
  object will be in. The addfile() method might have been able to read
  the file partially before it failed.  It is probably wise to discard
  or reset the $md5 object if this occurs.
  
  In most cases you want to make sure that the $io_handle is in
  C<binmode> before you pass it as argument to the addfile() method.
  
  =item $md5->add_bits($data, $nbits)
  
  =item $md5->add_bits($bitstring)
  
  Since the MD5 algorithm is byte oriented you might only add bits as
  multiples of 8, so you probably want to just use add() instead.  The
  add_bits() method is provided for compatibility with other digest
  implementations.  See L<Digest> for description of the arguments
  that add_bits() take.
  
  =item $md5->digest
  
  Return the binary digest for the message.  The returned string will be
  16 bytes long.
  
  Note that the C<digest> operation is effectively a destructive,
  read-once operation. Once it has been performed, the C<Digest::MD5>
  object is automatically C<reset> and can be used to calculate another
  digest value.  Call $md5->clone->digest if you want to calculate the
  digest without resetting the digest state.
  
  =item $md5->hexdigest
  
  Same as $md5->digest, but will return the digest in hexadecimal
  form. The length of the returned string will be 32 and it will only
  contain characters from this set: '0'..'9' and 'a'..'f'.
  
  =item $md5->b64digest
  
  Same as $md5->digest, but will return the digest as a base64 encoded
  string.  The length of the returned string will be 22 and it will only
  contain characters from this set: 'A'..'Z', 'a'..'z', '0'..'9', '+'
  and '/'.
  
  
  The base64 encoded string returned is not padded to be a multiple of 4
  bytes long.  If you want interoperability with other base64 encoded
  md5 digests you might want to append the string "==" to the result.
  
  =back
  
  
  =head1 EXAMPLES
  
  The simplest way to use this library is to import the md5_hex()
  function (or one of its cousins):
  
      use Digest::MD5 qw(md5_hex);
      print "Digest is ", md5_hex("foobarbaz"), "\n";
  
  The above example would print out the message:
  
      Digest is 6df23dc03f9b54cc38a0fc1483df6e21
  
  The same checksum can also be calculated in OO style:
  
      use Digest::MD5;
      
      $md5 = Digest::MD5->new;
      $md5->add('foo', 'bar');
      $md5->add('baz');
      $digest = $md5->hexdigest;
      
      print "Digest is $digest\n";
  
  With OO style, you can break the message arbitrarily.  This means that we
  are no longer limited to have space for the whole message in memory, i.e.
  we can handle messages of any size.
  
  This is useful when calculating checksum for files:
  
      use Digest::MD5;
  
      my $filename = shift || "/etc/passwd";
      open (my $fh, '<', $filename) or die "Can't open '$filename': $!";
      binmode($fh);
  
      $md5 = Digest::MD5->new;
      while (<$fh>) {
          $md5->add($_);
      }
      close($fh);
      print $md5->b64digest, " $filename\n";
  
  Or we can use the addfile method for more efficient reading of
  the file:
  
      use Digest::MD5;
  
      my $filename = shift || "/etc/passwd";
      open (my $fh, '<', $filename) or die "Can't open '$filename': $!";
      binmode ($fh);
  
      print Digest::MD5->new->addfile($fh)->hexdigest, " $filename\n";
  
  Perl 5.8 support Unicode characters in strings.  Since the MD5
  algorithm is only defined for strings of bytes, it can not be used on
  strings that contains chars with ordinal number above 255.  The MD5
  functions and methods will croak if you try to feed them such input
  data:
  
      use Digest::MD5 qw(md5_hex);
  
      my $str = "abc\x{300}";
      print md5_hex($str), "\n";  # croaks
      # Wide character in subroutine entry
  
  What you can do is calculate the MD5 checksum of the UTF-8
  representation of such strings.  This is achieved by filtering the
  string through encode_utf8() function:
  
      use Digest::MD5 qw(md5_hex);
      use Encode qw(encode_utf8);
  
      my $str = "abc\x{300}";
      print md5_hex(encode_utf8($str)), "\n";
      # 8c2d46911f3f5a326455f0ed7a8ed3b3
  
  =head1 SEE ALSO
  
  L<Digest>,
  L<Digest::MD2>,
  L<Digest::SHA>,
  L<Digest::HMAC>
  
  L<md5sum(1)>
  
  RFC 1321
  
  http://en.wikipedia.org/wiki/MD5
  
  The paper "How to Break MD5 and Other Hash Functions" by Xiaoyun Wang
  and Hongbo Yu.
  
  =head1 COPYRIGHT
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
   Copyright 1998-2003 Gisle Aas.
   Copyright 1995-1996 Neil Winton.
   Copyright 1991-1992 RSA Data Security, Inc.
  
  The MD5 algorithm is defined in RFC 1321. This implementation is
  derived from the reference C code in RFC 1321 which is covered by
  the following copyright statement:
  
  =over 4
  
  =item
  
  Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
  rights reserved.
  
  License to copy and use this software is granted provided that it
  is identified as the "RSA Data Security, Inc. MD5 Message-Digest
  Algorithm" in all material mentioning or referencing this software
  or this function.
  
  License is also granted to make and use derivative works provided
  that such works are identified as "derived from the RSA Data
  Security, Inc. MD5 Message-Digest Algorithm" in all material
  mentioning or referencing the derived work.
  
  RSA Data Security, Inc. makes no representations concerning either
  the merchantability of this software or the suitability of this
  software for any particular purpose. It is provided "as is"
  without express or implied warranty of any kind.
  
  These notices must be retained in any copies of any part of this
  documentation and/or software.
  
  =back
  
  This copyright does not prohibit distribution of any version of Perl
  containing this extension under the terms of the GNU or Artistic
  licenses.
  
  =head1 AUTHORS
  
  The original C<MD5> interface was written by Neil Winton
  (C<N.Winton@axion.bt.co.uk>).
  
  The C<Digest::MD5> module is written by Gisle Aas <gisle@ActiveState.com>.
  
  =cut
I686-LINUX_DIGEST_MD5

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE

use App::Every;

App::Every->main( @ARGV );

=pod

=head1 NAME

every - Easily create and queue cronjobs from the command line

=head1 SYNOPSIS

Form: every [--help] [-n|--dry-run] [-l] ([num] unit)... [--] program

For example:

    every day dosomething

    every 3 hours dosomething

    every @reboot dosomething

=head1 DESCRIPTION

Create and installs a crontab entry for you from a simple readable
specifier.  To see what crontab the tool will create, pass just --dry-run or
-n and it will print out the crontab entry without installing it.  Crontabs
will be installed in the current user's crontab.  You can view them in the
usual way (ie, crontab -l).

Commands will always be run from the directory you were in when you ran
every, so "./do_something" is perfectly valid.

The "-l" command provides job locking, so that if your command hasn't exited
by the time cron ticks again, you won't end up with second copy running.

=head1 OPTIONS

--help - Display this page.

--dry-run

-n     - Don't actually install the crontab

-l     - Add locking so that more then one copy can't run at once

num    - Number of the unit, defaults to 1

unit   - Unit can be min(ute)(s), hour(s), day(s), week(s), month(s) or the
name of a day of week, eg tue(sday).

Or instead of a number plus a unit, you can pass in @daily, @weekly, @yearly
or @reboot which will cause your command to be run every day, week, year or
on reboot, respectively.

=head1 JUSTIFICATION

This is intended to be as easy to use as "at", but for recurring jobs rather
then one-offs.  I'd found myself having a bad habit of running tasks in
loops in my shell with sleeps, rather then creating cron entries-- this is
intended to encourage me (and you!) to actually use cron.

One major thing I'm likely to add, is to export some of your environment, in
particular, your path.


=head1 AUTHOR

Rebecca Turner <becca@referencethis.com>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2012 by Rebecca Turner.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=head1 DISCLAIMER OF WARRANTY

BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT
WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
PARTIES PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND,
EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

=cut

